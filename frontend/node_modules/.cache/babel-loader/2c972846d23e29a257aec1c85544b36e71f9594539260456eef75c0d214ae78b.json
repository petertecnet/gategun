{"ast":null,"code":"//\n// Chart extension for making the bars rounded\n// Code from: https://codepen.io/jedtrow/full/ygRYgo\n//\nimport Chart from 'chart.js';\nChart.elements.Rectangle.prototype.draw = function () {\n  let ctx = this._chart.ctx;\n  let vm = this._view;\n  let left, right, top, bottom, signX, signY, borderSkipped, radius;\n  let borderWidth = vm.borderWidth;\n  // Set Radius Here\n  // If radius is large enough to cause drawing errors a max radius is imposed\n  let cornerRadius = 6;\n  if (!vm.horizontal) {\n    // bar\n    left = vm.x - vm.width / 2;\n    right = vm.x + vm.width / 2;\n    top = vm.y;\n    bottom = vm.base;\n    signX = 1;\n    signY = bottom > top ? 1 : -1;\n    borderSkipped = vm.borderSkipped || 'bottom';\n  } else {\n    // horizontal bar\n    left = vm.base;\n    right = vm.x;\n    top = vm.y - vm.height / 2;\n    bottom = vm.y + vm.height / 2;\n    signX = right > left ? 1 : -1;\n    signY = 1;\n    borderSkipped = vm.borderSkipped || 'left';\n  }\n\n  // Canvas doesn't allow us to stroke inside the width so we can\n  // adjust the sizes to fit if we're setting a stroke on the line\n  if (borderWidth) {\n    // borderWidth shold be less than bar width and bar height.\n    let barSize = Math.min(Math.abs(left - right), Math.abs(top - bottom));\n    borderWidth = borderWidth > barSize ? barSize : borderWidth;\n    let halfStroke = borderWidth / 2;\n    // Adjust borderWidth when bar top position is near vm.base(zero).\n    let borderLeft = left + (borderSkipped !== 'left' ? halfStroke * signX : 0);\n    let borderRight = right + (borderSkipped !== 'right' ? -halfStroke * signX : 0);\n    let borderTop = top + (borderSkipped !== 'top' ? halfStroke * signY : 0);\n    let borderBottom = bottom + (borderSkipped !== 'bottom' ? -halfStroke * signY : 0);\n    // not become a vertical line?\n    if (borderLeft !== borderRight) {\n      top = borderTop;\n      bottom = borderBottom;\n    }\n    // not become a horizontal line?\n    if (borderTop !== borderBottom) {\n      left = borderLeft;\n      right = borderRight;\n    }\n  }\n  ctx.beginPath();\n  ctx.fillStyle = vm.backgroundColor;\n  ctx.strokeStyle = vm.borderColor;\n  ctx.lineWidth = borderWidth;\n\n  // Corner points, from bottom-left to bottom-right clockwise\n  // | 1 2 |\n  // | 0 3 |\n  let corners = [[left, bottom], [left, top], [right, top], [right, bottom]];\n\n  // Find first (starting) corner with fallback to 'bottom'\n  let borders = ['bottom', 'left', 'top', 'right'];\n  let startCorner = borders.indexOf(borderSkipped, 0);\n  if (startCorner === -1) {\n    startCorner = 0;\n  }\n  function cornerAt(index) {\n    return corners[(startCorner + index) % 4];\n  }\n\n  // Draw rectangle from 'startCorner'\n  let corner = cornerAt(0);\n  ctx.moveTo(corner[0], corner[1]);\n  for (let i = 1; i < 4; i++) {\n    corner = cornerAt(i);\n    let nextCornerId = i + 1;\n    if (nextCornerId == 4) {\n      nextCornerId = 0;\n    }\n    let nextCorner = cornerAt(nextCornerId);\n    let width = corners[2][0] - corners[1][0];\n    let height = corners[0][1] - corners[1][1];\n    let x = corners[1][0];\n    let y = corners[1][1];\n    let radius = cornerRadius;\n\n    // Fix radius being too large\n    if (radius > height / 2) {\n      radius = height / 2;\n    }\n    if (radius > width / 2) {\n      radius = width / 2;\n    }\n    ctx.moveTo(x + radius, y);\n    ctx.lineTo(x + width - radius, y);\n    ctx.quadraticCurveTo(x + width, y, x + width, y + radius);\n    ctx.lineTo(x + width, y + height - radius);\n    ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);\n    ctx.lineTo(x + radius, y + height);\n    ctx.quadraticCurveTo(x, y + height, x, y + height - radius);\n    ctx.lineTo(x, y + radius);\n    ctx.quadraticCurveTo(x, y, x + radius, y);\n  }\n  ctx.fill();\n  if (borderWidth) {\n    ctx.stroke();\n  }\n};","map":{"version":3,"names":["Chart","elements","Rectangle","prototype","draw","ctx","_chart","vm","_view","left","right","top","bottom","signX","signY","borderSkipped","radius","borderWidth","cornerRadius","horizontal","x","width","y","base","height","barSize","Math","min","abs","halfStroke","borderLeft","borderRight","borderTop","borderBottom","beginPath","fillStyle","backgroundColor","strokeStyle","borderColor","lineWidth","corners","borders","startCorner","indexOf","cornerAt","index","corner","moveTo","i","nextCornerId","nextCorner","lineTo","quadraticCurveTo","fill","stroke"],"sources":["C:/xampp/htdocs/gategun/frontend/src/components/Charts/roundedCornersExtension.js"],"sourcesContent":["//\n// Chart extension for making the bars rounded\n// Code from: https://codepen.io/jedtrow/full/ygRYgo\n//\nimport Chart from 'chart.js'\nChart.elements.Rectangle.prototype.draw = function() {\n\n  let ctx = this._chart.ctx;\n  let vm = this._view;\n  let left, right, top, bottom, signX, signY, borderSkipped, radius;\n  let borderWidth = vm.borderWidth;\n  // Set Radius Here\n  // If radius is large enough to cause drawing errors a max radius is imposed\n  let cornerRadius = 6;\n\n  if (!vm.horizontal) {\n    // bar\n    left = vm.x - vm.width / 2;\n    right = vm.x + vm.width / 2;\n    top = vm.y;\n    bottom = vm.base;\n    signX = 1;\n    signY = bottom > top ? 1 : -1;\n    borderSkipped = vm.borderSkipped || 'bottom';\n  } else {\n    // horizontal bar\n    left = vm.base;\n    right = vm.x;\n    top = vm.y - vm.height / 2;\n    bottom = vm.y + vm.height / 2;\n    signX = right > left ? 1 : -1;\n    signY = 1;\n    borderSkipped = vm.borderSkipped || 'left';\n  }\n\n  // Canvas doesn't allow us to stroke inside the width so we can\n  // adjust the sizes to fit if we're setting a stroke on the line\n  if (borderWidth) {\n    // borderWidth shold be less than bar width and bar height.\n    let barSize = Math.min(Math.abs(left - right), Math.abs(top - bottom));\n    borderWidth = borderWidth > barSize ? barSize : borderWidth;\n    let halfStroke = borderWidth / 2;\n    // Adjust borderWidth when bar top position is near vm.base(zero).\n    let borderLeft = left + (borderSkipped !== 'left' ? halfStroke * signX : 0);\n    let borderRight = right + (borderSkipped !== 'right' ? -halfStroke * signX : 0);\n    let borderTop = top + (borderSkipped !== 'top' ? halfStroke * signY : 0);\n    let borderBottom = bottom + (borderSkipped !== 'bottom' ? -halfStroke * signY : 0);\n    // not become a vertical line?\n    if (borderLeft !== borderRight) {\n      top = borderTop;\n      bottom = borderBottom;\n    }\n    // not become a horizontal line?\n    if (borderTop !== borderBottom) {\n      left = borderLeft;\n      right = borderRight;\n    }\n  }\n\n  ctx.beginPath();\n  ctx.fillStyle = vm.backgroundColor;\n  ctx.strokeStyle = vm.borderColor;\n  ctx.lineWidth = borderWidth;\n\n  // Corner points, from bottom-left to bottom-right clockwise\n  // | 1 2 |\n  // | 0 3 |\n  let corners = [\n    [left, bottom],\n    [left, top],\n    [right, top],\n    [right, bottom]\n  ];\n\n  // Find first (starting) corner with fallback to 'bottom'\n  let borders = ['bottom', 'left', 'top', 'right'];\n  let startCorner = borders.indexOf(borderSkipped, 0);\n  if (startCorner === -1) {\n    startCorner = 0;\n  }\n\n  function cornerAt(index) {\n    return corners[(startCorner + index) % 4];\n  }\n\n  // Draw rectangle from 'startCorner'\n  let corner = cornerAt(0);\n  ctx.moveTo(corner[0], corner[1]);\n\n  for (let i = 1; i < 4; i++) {\n    corner = cornerAt(i);\n    let nextCornerId = i + 1;\n    if (nextCornerId == 4) {\n      nextCornerId = 0\n    }\n\n    let nextCorner = cornerAt(nextCornerId);\n\n    let width = corners[2][0] - corners[1][0];\n    let height = corners[0][1] - corners[1][1];\n    let x = corners[1][0];\n    let y = corners[1][1];\n\n    let radius = cornerRadius;\n\n    // Fix radius being too large\n    if (radius > height / 2) {\n      radius = height / 2;\n    }\n    if (radius > width / 2) {\n      radius = width / 2;\n    }\n\n    ctx.moveTo(x + radius, y);\n    ctx.lineTo(x + width - radius, y);\n    ctx.quadraticCurveTo(x + width, y, x + width, y + radius);\n    ctx.lineTo(x + width, y + height - radius);\n    ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);\n    ctx.lineTo(x + radius, y + height);\n    ctx.quadraticCurveTo(x, y + height, x, y + height - radius);\n    ctx.lineTo(x, y + radius);\n    ctx.quadraticCurveTo(x, y, x + radius, y);\n\n  }\n\n  ctx.fill();\n  if (borderWidth) {\n    ctx.stroke();\n  }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}